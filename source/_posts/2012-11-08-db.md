---
title: 数据库模块
layout: post
categories: dev
published: true

---

当前实现的数据库模块仅支持 SQLite3。

## 配置约定

`CONFIG/db` 目录下每个子目录对应一个数据库，子目录名称即数据库名称，在每个子目录下，有若干配置文件（YAML 标记语言文件），每个配置文件对应一个数据表，文件名称即数据表名称。由数据库模块生成的 SQLite 数据库文件存储在 `db` 目录中。

在数据库模块初始化时，如果相应的数据库不存在或为空（以 `ATTACH` 实现），则根据上述约定及配置创建数据库及数据表。

*警告*：`ATTACH` 失败的情况目前未做处理。

强制表的第一个字段作为主键，但依然建议为第一个字段添加声明 `PRIMARY KEY UNIQUE`，以兼容 SQLite3。

*警告*：强制仅为必须遵守的约定，实现中不会进行合法性检查，违反约定的情况目前未经测试，结果不可知。

## 数据结构

`Values` 和 `Table` 是数据库模块两种最主要的数据结构，`Values` 用来存取应用层与数据库交互的所有数据以及限定条件（`WHERE` 分句）等，`Table` 用来存取数据表结构。

### `Values`

`Values` 以 `map` 容器存储 `value_t` 表示的数据，支持以 key-value 的形式访问数据。

    {% codeblock lang:c++ %}
    enum value_type_t {
        ELF_VALUE_INT,
        ELF_VALUE_FLOAT,
        ELF_VALUE_RAW,
        ELF_VALUE_TEXT,
        ELF_VALUE_UID,
    };

    struct value_t {
        // raw buffer
        struct raw_t {
            void *data;
            size_t size;
        };

        union data_t {
            int n;
            double f;
            raw_t b;
        };
        data_t data;
        value_type_t type;
    };

    typedef std::map<std::string, value_t *> value_map;
    {% endcodeblock %}

#### 关于数据类型的一点思考

出于国际化需要，在与代码执行无关时，尽量不要使用字符串，而应以资源 ID 代替，尽量避免使用复杂数据类型。

只是为了提供一种简明高效的扩展，扩展是第二位的，简明高效是第一位的。

毕竟，绝大多数数据都可以使用数值型，而诸如 GUID、用户类型等数据是个别的，不具有通用性和易读性，扩展意义不大。

对于浮点型数据的处理，保留小数点后两位，进行读写运算时，可放大 100 倍后使用。甚至设计时，就可规避。

### `Table`

与 `Values` 类似，`Table` 以 `vector` 容器存储 `field_t` 表示的字段，为了简化数据库操作，与数据表中字段顺序保持一致，在 `Values` 数据写数据库时，即通过 `Table` 完成序列化操作。

    {% codeblock lang:c++ %}
    struct field_t {
        std::string name;
        std::string type;
        std::string defination;
        value_type_t ctype;
    };

    typedef std::vector<field_t *> field_list;
    {% endcodeblock %}

## 实现

目前的数据库模块支持以下接口：

    {% codeblock lang:c++ %}
    int db_init(void);
    int db_fini(void);

    int db_insert(const char *cmd, const Elf::values_list &in);
    int db_update(const char *cmd, const Elf::Values *con,
                  const Elf::values_list &in);

    int db_query(const char *cmd, Elf::values_list &out);
    int db_select(const char *cmd, const Elf::Values *con,
                  Elf::values_list &out);

    int db_exec(const char *cmd);
    int db_execsql(const char *sql);
    {% endcodeblock %}

### 执行 SQL 语句

虽然 `db_execex` 接口支持直接执行 SQL 语句，但出于安全、方便，这种做法是不被推荐的。而且，`db_exec` 没有任何输出，因此，不支持查询等结果返回功能。对于数据库操作，推荐使用下面介绍的数据库操作命令方式。

### 数据库操作命令

#### 预定义数据库操作命令

数据库操作命令是为简化数据库操作而设计的，推荐格式采用点分形式：`db.table.command`。在加载数据表结构时，为每个 `Table` 对象预定义了若干常用命令：

* `count`: `SELECT count(*) AS count`
* `create`: `CREATE TABLE`
* `insert`: `INSERT`
* `update`: `UPDATE`
* `select`: `SELECT * WHERE`
* `selectall`: `SELECT *`
* `display`: `display`

其中，最后一项 `display` 以格式化文本形式输出数据表结构。

在使用这些预定义命令时，需要严格遵循前述点分形式，如 `account.user.create`，数据库模块将解析命令，根据数据表名称（如 `account.user`）及命令名称（如 `create`）。

需要注意的是，目前实现中：

* `count`：记录统计，仅支持 `SELECT count(*) AS count FROM table1` 的语义，不支持条件统计。
* `insert`：数据插入，仅支持 `INSERT INTO table1 VALUES(...)` 的语义。
* `select`：条件查询，仅支持 `WHERE column1=value1 AND column2=value2 AND ...` 的语义。

可以使用下面的自定义数据库操作命令完成相应需求。

#### 自定义数据库操作命令

如果预定义操作命令不存在，数据库模块将尝试使用自定义数据库操作命令。在 `CONFIG/db` 目录下，名为 `commands.yml` 的配置文件中可存取自定义的 SQL 语句，示例如下：

    {% codeblock lang:ruby %}
    test: SELECT count(*) AS count FROM account.user
    account:
      user:
        count: SELECT count(*) AS count FROM account.user
        test_p0000: SELECT * FROM account.user WHERE user = 'p0000'
    {% endcodeblock %}

如示例所示，对于自定义数据库操作命令，并不严格要求使用 `db.table.command` 的点分形式，但点分形式仍然是推荐做法。

