---
title: Values & Object
layout: post
categories: dev
published: true

---

## `Values` 与 `Object` 派生体系

所有 `Object` 及其派生类的逻辑数据均存储在一个 `Values` 容器（`_properties`）中，采用 key-value 形式的突出优点是灵活性高，但缺点是每次访问时需要查找，效率不高。针对这一点，有两种优化思路：

* 采用或借鉴 protobuf 协议及实现，完成 Values -> protobuf -> C++ class 的代码生成机制。

* 针对使用频率高的属性进行硬编码绑定（添加数据成员），并在 `set` 操作中同步 `_properties`，在保证所有 `set` 操作同步（即序列化）的情况下，`Serialize()` 甚至不再需要，因为 `_properties` 即序列化结果。

    {% codeblock lang:c++ %}
    class Object {
    public:
        virtual bool Serialize(void);
        virtual bool Deserialize(Values *vals);

        ELF_INL const uid_t &GetID(void) const { return _id; }

    protected:
        Object(void);
        virtual ~Object(void);

        void SetID(const uid_t &uid = UID_NIL) {
            if (uid == UID_NIL) {
                uid_create(_id);
            } else {
                _id = uid;
            }
        }

        uid_t _id;
        Values *_properties;
    };

    class Account: public Object {
    protected:
        Account(void);
        virtual ~Account(void);

        ELF_INL void SetUser(const std::string &user) {
            _user = user;
            _properties->Set("user", _user.c_str());
        }

        ELF_INL void SetMail(const std::string &mail) {
            _mail = mail;
            _properties->Set("mail", _mail.c_str());
        }

        std::string _user;
        std::string _mail;
    };
    {% endcodeblock %}

### 关于 `Object` 派生体系的序列化与反序列化

*警告*：由于 `Object` 及其派生类对 `_properties` 具有较强依赖，因此所有派生类的 `Serialize()` 及 `Deserialize()` 实现必须调用其父类的实现。否则，容易引起逻辑数据错误及内存使用错误。
