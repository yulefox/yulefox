---
title: TUT 初探
layout: post
categories: dev
tags: 开发 C++ 测试
published: true

---

之前写代码时，都是根据自己需要编写一个简易的单元测试框架。最近在读 [VLD](http://vld.codeplex.com/) 源码时，了解了一下 [TUT](http://tut-framework.sourceforge.net/)。

TUT（Template Unit Tests）是一个纯 C++ 单元测试框架。

* 可移植性好，对编译器和操作系统几乎没有任何依赖。

* 完全使用 C++ 模板实现，故仅需包含头文件，不依赖特定库，部署简单。

* 自定义报告接口，方便集成到任意 IDE 或工具。

* 支持多进程测试。

* 在类 BSD 许可协议下可自由发布。

* 测试用例以具名测试组（named test groups）的方式进行组织。

* 支持回归测试（测试所有用例），或以测试组或单个测试用例为单位。

* 纯 C++ 实现，不使用宏。

* 可读性好，易维护。 

## 特性

* 根据测试用例的相关性分组，每个测试组有自己的名称，属于自己的编译单元。一个测试组中的测试用例数量近乎无限（取决于编译器模板最大递归深度）。

* 用户可一次运行所有测试用例（回归测试），单个测试组或部分测试用例。

* 支持自定义回调接口进行格式输出，实现对测试过程及结果的跟踪。

* 作为模板库，无需编译，包含头文件 `<tut/tut.hpp>` 即可。

## 测试用例组织结构

一个单元测试项目由测试程序、测试用例、测试组组成。测试程序包含了所有测试用例，这些测试用例根据相关性组织成测试组。

### 测试程序（Test Application）

基于 TUT 的应用程序，用于进行自动/手动测试。

## 测试用例（Tests）

单个测试一般仅测试单个的特定功能，如，针对一个容器，一个测试用例用以测试在执行 `clear()` 后，调用 `size()` 返回值是否为 `0`。

### 测试组（Test Groups）

根据功能将所有测试用例划分为若干测试组，TUT 可直接调用具有唯一名称的测试组。通常，每个测试组对应一个 C++ 源文件。

## 编写测试程序

* 测试什么？测试应覆盖所有正确及错误的应用环境。

* 测试驱动的开发模式是一个不错的方案。

测试组定义为一个结构体/类，包含测试所需的数据作为成员。测试用例继承自测试组，从而可直接访问测试组的数据成员。

    {% codeblock lang:c++ %}
    namespace tut {
        struct my_test { // test group
        // methods and data
        };

        typedef test_group<my_test> tg;
        typedef tg::object object;
        tg my_group("my test");

        template<>
        template<>
        void object::test<1>() { // test
            // do something here
        }
    }

    using namespace tut;

    namespace tut {
    test_runner_singleton runner;
    }

    int main() // entrance of the test application
    {
        // run all tests in all groups
        runner.get().run_tests();

        // run all tests in group "my test"
        runner.get().run_tests("my test");

        // run test number 1 in group "my test"
        runner.get().run_test("my test"，1);

        return 0;
    }
    {% endcodeblock %}

运行测试时，每个测试对象都通过测试组的默认构造函数重新创建，因此，所有前置工作都被放在默认构造函数中完成。测试完成后，无论测试是否通过，测试对象均被析构，因此，清理工作也需要被放在析构函数中完成。

    {% codeblock lang:c++ %}
    // test_player.cpp

    #include <tut/tut.hpp>

    using namespace Elf;

    namespace tut {
    struct player {
        player() {
        }

        ~player() {
        }
    };

    typedef test_group<player> factory;
    typedef factory::object object;

    tut::factory tf("player");

    template<>
    template<>
    void object::test<1>() {
        set_test_name("Load Player");
        ensure(GetObjectManager().InitDB() == ELF_DB_RC_OK);

        Account *acc1 = GetObjectManager().LoadAccount("p0001");
        Account *acc2 = GetObjectManager().LoadAccount("p0001");
        Account *acc3 = GetObjectManager().LoadAccount("p10010");

        ensure(acc1 != NULL);
        ensure(acc2 != NULL);
        ensure(acc3 == NULL);
        ensure(acc1->PlayerCount() > 0);
        ensure(GetObjectManager().SavePlayers(acc1->GetID()));
        ensure(GetObjectManager().SavePlayers(acc1->GetID()));
    }
    }

    // main.cpp

    using namespace tut;

    namespace tut {
        test_runner_singleton runner;
    }

    void run(int argc, char **argv)
    {
        console_reporter cb(std::cout);

        runner.get().set_callback(&cb);
        try {
            if (strcmp(argv[1], "all") == 0) {
                runner.get().run_tests();
            } else {
                runner.get().run_tests(argv[1]);
            }
        } catch(const tut::no_such_group &ex) {
            std::cerr << "No such group: " << ex.what() << std::endl;
        } catch(const tut::tut_error &ex) {
            std::cout << "General error: " << ex.what() << std::endl;
        }
    }

    int main(int argc, char **argv)
    {
        BEGIN_CRASH_DUMP {
            elf_init();
            db_init();
            run(argc, argv);
            db_fini();
            elf_fini();
            exit(EXIT_SUCCESS);
        } CATCH_CRASH_DUMP {
            exit(EXIT_FAILURE);
        }
    }
{% endcodeblock %}

