---
title: 视野
layout: post
categories: dev
published: true

---

## 视野规则

* 最简单的视野实现是以对象坐标为圆心的一个圆形区域。最初考虑：为减轻服务器负载，服务器端视野的计算以格子为单位。在跟大家讨论之后，**发现在对象移动时刷新视野的方案并不合理，更好的方案是在确认对象周围有其他对象时重新计算视野可见对象，这样可以减少周围没有其他对象（结合实际应用，应该是没有其他阵营对象）时的无谓计算，而且还可以实现更精确地视野判定**。
* 视野外的对象不可见，同一阵营的对象共享视野（通常情况下互相可见），不同阵营的对象无法共享视野。
* 视野可能因下面的遮挡、开启规则而改变。

    {% codeblock lang:cpp %}
    enum FogMode {
        FOG_MODE_NONE,          // no fog, it is visible for the whole map
        FOG_MODE_BLACK,         // black fog, terrain invisible
        FOG_MODE_WAR,           // war fog, terrain visible
    };
    {% endcodeblock %}

按格子过滤：

![Enable/Disable View Fog (by Tiles)](/images/view_agents_fog.png)

### 阵营

* 中立
* A
* B

    {% codeblock lang:cpp %}
    enum CampType {
        CAMP_TYPE_N, // neutral camp 
        CAMP_TYPE_A, // camp A
        CAMP_TYPE_B, // camp B
        CAMP_TYPE_MAX,
    };
    {% endcodeblock %}

当前枚举值的使用只是为了测试方便，实际应用需要改变阵营数量时，无需使用枚举实现。

### 视野遮挡规则

* 具有一定高度的视野障碍物（墙体、山体、草丛等）对视线遮挡造成视野范围缩小
* 具有掩蔽效果的掩蔽体（迷雾、草丛、特定潜行区域等）可令其中的目标对外界（一般仅针对敌对阵营）不可见
* 处于潜行、隐身状态的特定对象对外界（一般仅针对敌对阵营）不可见
* 迷雾、致盲等效果可令对象视野缩小或完全不可见

视野的遮挡规则通过 *过滤器* 实现。

#### 视野过滤

最初在考虑基于格子实现视野功能时，通过过滤器对视野中的格子依次过滤，最终格子上的对象即纳入视野中。

每一种过滤器均会根据对应规则过滤掉部分 **对象**。

    {% codeblock lang:cpp %}
    enum FilterMode
    {
        FILTER_MODE_NONE             = 0x00000000,
        FILTER_MODE_INVISIBLE_SHAPE  = 0x00000001,
        FILTER_MODE_VIEW_BLOCK       = 0x00000002,
        FILTER_MODE_GRASS            = 0x00000004,
        FILTER_MODE_ALL              = -1,
    };
    {% endcodeblock %}

    {% codeblock lang:cpp %}
    // before: SetPosition()
    // Calculate the view field of the shape/camp.
    if (view->last != idx) {
        UpdateView(view);
        UpdateCampView(view);
    }
    // now: Update()
    // update the view of the other shapes around
    shape_map::iterator itr =  _shapes.begin();
    view_t *view = NULL;
    Shape *shape = NULL;

    for (; itr != _shapes.end(); ++itr) {
        view = itr->second;
        UpdateView(view);
    }

    void Map::UpdateView(view_t *view)
    {
        ELF_ASSERT(view);

        // copy
        const shape_map vs = view->shapes;

        GetShapesAround(view);
        FilterView(view);
        diff(vs, view->shapes, view->shapes_add, view->shapes_del);
        UpdateCampView(view);
    }
    {% endcodeblock %}

#### 视线阻挡过滤

* 山体
* 墙体
* 草丛

将视线不可及区域中的 **对象** 从视野区域中滤除。

#### 潜行对象过滤

* 潜行
* 隐身
* 草丛

#### 大体型对象处理

### 视野开启规则

为使视野具有连续性，避免造成闪烁，可考虑仅在客户端添加延迟移除视野显示的功能。

视野的开启需要借助具体对象实现，为之添加视野范围（目前仅考虑支持圆形视野，矢量视野等特性因暂无需求可不予考虑）属性，可为其自身及所属阵营开启视野。

* 角色、宠物、NPC 等具有视野的对象
* 通过技能、道具等创建的具有视野的对象（静止、移动）

### 视野实现

    {% codeblock lang:cpp %}
    // before
    struct view_t {
        int tile; // the index of the tile
        int last; // the index of the last tile
        int size; // the size of the view
        int anti_stealth; // the property of anti-stealth
        point_t pos; // the position of the shape
        CampType camp; // the camp of the view
        object_view_t field; // the cells of the view field
    };

    // now
    struct view_t {
        int tile; // tile index
        int last; // last tile index
        float range; // view range
        int anti_stealth; // anti-stealth
        point_t pos;
        CampType camp; // camp
        shape_map ext_shapes; // superset of the visible shapes
        shape_map shapes; // visible shapes
        shape_map shapes_add; // new added visible shapes
        shape_map shapes_del; // new deleted visible shapes
    };

    struct camp_t {
        shape_map members; // superset of the visible shapes
        view_map shapes; // visible shapes
        shape_map shapes_add; // new added shapes
        shape_map shapes_del; // new deleted shapes
    };
    {% endcodeblock %}

#### 反潜行视野

最初设计在统计格子视野的反潜行视野方案：

由于共享视野可能造成视野叠加，为正确实现视野变化，目前设计为视野添加了引用计数。

由于潜行、隐身等状态的存在，必然存在反潜行、隐身等具有真视效果的视野。目前考虑的实现方案是为视野添加反潜行属性。

为了区分普通视野及真视视野，为真视视野对应格子的引用计数叠加一个极大值 `0x00010000`。

    {% codeblock lang:cpp %}
    const int Map::VIEW_REFERENCE[2] = {1, 0x00010000};
    {% endcodeblock %}

**在基于对象的反潜行视野中，反潜行的功能简化为完全依赖过滤器实现**。

### 实现

**结合网络消息分发机制的实现，需要对对象移动进行帧率控制，并按帧分发移动、视野消息**。

在基于对象实现视野过滤的方案中，实现流程如下：

* 检索对象视野中的其他对象到一个集合中。
* 对非空对象集合应用过滤器组。
* 刷新阵营视野对象集合。
* **刷新相关对象（对象视野中的其他对象）的视野**。
* 对比各阵营对象集合在视野改变前后的变化，完成消息分发。

#### 移动与视野控制

![Shapes Around](/images/view_agents_around.png)

![Shapes Around With Connection](/images/view_agents_around_connection.png)

![Shapes Around Filtered By Blocks](/images/view_agents_filtered.png)

![Camp View/Disable Flog](/images/view_agents_all.png)

![Camp View/Camp A](/images/view_agents_camp_a.png)

![Camp View/Camp B](/images/view_agents_camp_b.png)

![Camp View/Camp N](/images/view_agents_camp_n.png)

#### 测试效果

帧率：10
对象数量：100
自动添加/删除对象：允许

当对象数量在 100 以下时，效果还是可以接受的；超过 100 之后，有比较明显的卡顿现象。主要原因是过多的对象聚集在同一区域，加重了视野的计算量。

帧率：10
对象数量：150
自动添加/删除对象：不允许

当对象数量在 150 以下时，效果还是可以接受的；超过 180 之后，有比较明显的卡顿现象。此时，整个场景基本布满对象，视野计算量较大。

#### 实现注意事项

* 需要明确视野不可见、目标不可见在实现方式上的区别
  * 视野：场景
  * 隐身：对象

## 场景

### 场景初始化及释放

基于场景模版（场景网格数据）创建场景对象。

    {% codeblock lang:cpp %}
    Map::Init();
    Map *map = Map::Create(id);
    Map::Fini();
    {% endcodeblock %}

### 添加对象

在场景初始化之后，即可往场景上添加可见的物体对象（`Shape`），以玩家对象为例：

* 创建对象；
* 设置阵营；
* 设置坐标/加入场景。

    {% codeblock lang:cpp %}
    Player *player = static_cast<Player *>(GetObjectManager().
            Create(OBJECT_TYPE_PLAYER));

    player->Set("camp", (Map::CampType)camp);

    map->SetPosition(player, (const point_t &)pos);
    {% endcodeblock %}

    {% codeblock lang:cpp %}
    // 1. The shape is a new one. Add it to the current map.
    // 2. The shape is on another map. Remove it from the last map and add it
    //    to the current.
    // 3. The shape is on the current map already. Remove the last flags.

    // Calculate the view field of the shape/camp.
    if (view->last != idx) {
        UpdateView(view);
        UpdateCampView(view);
    }
    {% endcodeblock %}


### 场景对象管理

    {% codeblock lang:cpp %}
    ELF_INL const shape_map &GetShapes(void) const { return _shapes; }
    void GetShapes(object_list &shapes) const;
    void GetShapes(Map::CampType camp, object_list &shapes) const;
    bool Has(const Shape *shape) const;
    bool IsBlock(int idx) const { return _mesh->tiles[idx].obstruction > 0; }

    void RemoveShape(Shape *shape);
    void SetPosition(Shape *shape, const point_t &pos);

    void GetShapesAround(const point_t &cent, float radius,
        shape_map &shapes) const;

    void GetBlocksAround(const point_t &cent, float radius,
        tile_list &tiles) const;

    void FilterShapesByTiles(const point_t &cent, const tile_list &tiles,
        shape_map &shapes) const;
    {% endcodeblock %}

## 网络通信实现

视野变化仅影响客户端显示及玩家游戏感受，对于服务器逻辑没有影响。

### 服务器/客户端对象管理

目前服务器在处理客户端对象的添加删除时，规则比较统一：

* `MSG_S2C_RGN_ADDSHAPE`
  * `CServerRegion::AddMonster` 通过 `CMessage::SendToAround` 广播
  * `CServerRegion::OnRebornObject`（`CMonster`） 通过 `CMessage::SendToAround` 广播
  * `CServerRegion::SendAddShapeMsgToClient` 通过 `CMessage::SendToPlayers` 广播（区分是否可见）

在每次发送 `MSG_S2C_RGN_ADDSHAPE` 消息时，需要重新编码对象数据。

