---
title: Lua 的面向对象编程
published: true
layout: post

---

## 概述

Lua 并未定位于面向对象语言，但其强大的元编程思想使之可以直接定义类对象。

Lua 的元表为面向对象编程提供了有力支持，表的行为可以通过为其指定元表自定义实现。例如，访问表中不存在的字段时，解释器会查找名为 `__index` 的元方法，如果 `__index` 是一个表，解释器将从该表中查找字段；如果 `__index` 是一个函数，解释器会调用该函数；如果 `__index` 不存在，则返回 `nil`。

## 第一种实现

    {% codeblock lang:lua %}
    account = {}
    account.__index = account

    function account.create(balance)
        local acnt = {}             -- our new object
        setmetatable(acnt, account) -- make account handle lookup
        acnt.balance = balance      -- initialize our object
        return acnt
    end

    function account:withdraw(amount)
        self.balance = self.balance - amount
    end

    -- create and use an account
    acc = account.create(1000)
    acc:withdraw(100)
    {% endcodeblock %}

`account` 是一个表，只包含一个字段 `balance`。`acc` 也是一个表，由于在 `account.create` 中将 `account` 指定为其元表（原型），且该原型的 `__index` 元方法为 `account`。因此在访问 `acc:withdraw()` 时，`acc` 没有 `withdraw()`，解释器访问 `acc` 的 `__index`（即 `account` 的 `__index`：`account`），因此实际访问的是 `account:withdraw()` 函数。从面向对象的角度，`acc` 成为 `account` 的一个实例。

## 第二种实现（推荐）

先从使用方式开始看：

    {% codeblock lang:lua %}
    account = class(function(acc, balance)
        acc.balance = balance
        end)

    function account:withdraw(amount)
        self.balance = self.balance - amount
    end

    -- can create an account using call notation!
    acc = account(1000)
    acc:withdraw(100)
    {% endcodeblock %}

`account` 作为 `class()` 函数的返回值，其实例化过程更接近面向对象的写法，`acc = account(1000)` 像是一次构造函数调用。

再看一个继承的示例：

    {% codeblock lang:lua %}
    animal = class(function(a, name)
       a.name = name
    end)

    function animal:__tostring()
      return self.name .. ': ' .. self:speak()
    end

    dog = class(animal)

    function dog:speak()
      return 'bark'
    end

    cat = class(animal, function(c, name, breed)
             animal.init(c, name)  -- must init base!
             c.breed = breed
          end)

    function cat:speak()
      return 'meow'
    end

    lion = class(cat)

    function lion:speak()
      return 'roar'
    end

    fido = dog('Fido')
    felix = cat('Felix', 'Tabby')
    leo = lion('Leo', 'African')
    {% endcodeblock %}

该例中，`animal`/`dog`/`cat`/`lion` 的继承关系比较清晰，`animal` 的 `__tostring` 元方法供 `tostring()` 访问。

接下来了解 `class` 的实现：

    {% codeblock lang:lua %}
    function class(base, init)
        local c = {}    -- a new class instance
        if not init and type(base) == 'function' then
            init = base
            base = nil
        elseif type(base) == 'table' then
            -- our new class is a shallow copy of the base class!
            for i,v in pairs(base) do
                c[i] = v
            end
            c._base = base
        end
        -- the class will be the metatable for all its objects,
        -- and they will look up their methods in it.
        c.__index = c

        -- expose a constructor which can be called by <classname>(<args>)
        local mt = {}
        mt.__call = function(class_tbl, ...)
            local obj = {}
            setmetatable(obj, c)
            if init then
                init(obj, ...)
            else 
                -- make sure that any stuff from the base class is initialized!
                if base and base.init then
                    base.init(obj, ...)
                end
            end
            return obj
        end
        c.init = init
        c.is_a = function(self, cls)
            local m = getmetatable(self)
            while m do 
                if m == cls then return true end
                m = m._base
            end
            return false
        end
        setmetatable(c, mt)
        return c
    end
    {% endcodeblock %}

`class()` 函数可支持两个可选参数：`base`、`init`，`base` 为基类（表），用于实现继承、复制；`init` 为初始化函数，即 *构造函数*。需要注意的是，子类的初始化函数需要调用父类的初始化函数，以完成正确继承（毕竟 Lua 自身没有提供面向对象的继承机制）。

`class()` 使用两个技巧：

* 支持 *构造函数*：通过指定元方法 `__call` 实现。
* 支持 *继承*：通过复制基类字段到子类中，此方法比通过 `__index` 实现效率更高。

参考：[原文](http://lua-users.org/wiki/SimpleLuaClasses) 在这里。

